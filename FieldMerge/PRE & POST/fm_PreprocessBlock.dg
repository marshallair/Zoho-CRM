string standalone.PreprocessBlock(String Text, String strIndex, int OpenDelimiterLocation, String CloseDelimiter,String FunctionCharacter)
{
// USAGE
//  standalone.PreprocessBlock(MergetText,Index,OpenDelimiter,CloseDelimiter,FunctionCharacter).toMap()
//
// NOTES
//  Processes Text starting from position 0 as the next block. Returns a map string that needs added to ResultsMap, with a block type always starting first, then preload blocks, such as:
//  {"blocktype":"IF_RESULT","preload_blocks":{[0,1,3,0]:"IF_COND",[0,1,3,1],[0,1,3,2]:"IF_TRUE",[0,1,3,3]:"IF_FALSE"}}
//  Care needs taken to add the blocktype block and the preload blocks to ResultsMap immediately after calling this function.
//
// TEST
// Text = "$F${id,ID: {$},missing}";
// Index = {0,0,1};
//
// ERROR CHECKS
if(isblank(Text))
{
	return "Text is blank when passed to PreprocessBlock()";
}
if(isblank(strIndex))
{
	return "strIndex is blank when passed to PreprocessBlock()";
}
//
// DEFAULTS
if(OpenDelimiter == "")
{
	OpenDelimiter = "{";
}
if(CloseDelimiter == "")
{
	CloseDelimiter = "}";
}
if(FunctionCharacter == "")
{
	FunctionCharacter = "$";
}
// VARIABLES
m = Map();
Index = strIndex.toList();
//
// FUNCTION
//
// Every function and operator is evaluated. To add new operators or functions, add them here, minding their order if necessary, and call their associated standalone function.
	if(standalone.IsBlockThisFunction("IF",Text,BlockDelimiterLocation,FunctionCharacter))
{
	// IF function
	m.putAll(standalone.fmfunc_IF(true,Index,null).toMap());
}
else if(standalone.IsBlockThisFunction("AND",Text,BlockDelimiterLocation,FunctionCharacter))
{
	// AND function
	m.putAll(standalone.fmfunc_AND(true,Index,null).toMap());
}
else if(standalone.IsBlockThisFunction("NAND",Text,BlockDelimiterLocation,FunctionCharacter))
{
	// NAND function
	m.putAll(standalone.fmfunc_NAND(true,Index,null).toMap());
}
else if(standalone.IsBlockThisFunction("F",Text,BlockDelimiterLocation,FunctionCharacter) || upper(Text.mid(BlockDelimiterLocation - 1,BlockDelimiterLocation)) == FunctionCharacter)
{
	m.putAll(standalone.fmfunc_FIELD(true,Index,null).toMap());
	// Field (F) function (simplified Field ${} must be evaluated last to make sure it doesn't match any other functions)
}
else
{
	// plain block {}
	m.put(Index,"BLOCK");
}
//
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Check for preceding text
if(OpenDelimiterLocation > 0)
{
	ResultsMap.put(CurrentIndex.duplicate(0).toList(),MergeText.mid(TextCursor, OpenDelimiterLocation + TextCursor));
	CurrentIndex = standalone.IncrementSequentialIndex(CurrentIndex).toList(",");
}
//
// Add preprocess key-value pairs to map
ResultsMap.putAll(standalone.PreprocessBlock(MergeText.mid(cursor,OpenDelimiterLocation+1), CurrentIndex, OpenDelimiter, CloseDelimiter, FunctionCharacter).toMap());
//

return m;
}