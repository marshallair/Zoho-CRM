string standalone.TestStructures(string MergeText, string Data, string OpenDelimiter, string CloseDelimiter, string FunctionCharacter)
{
// Sample Data
// MergeText="My name is {${PersTitle} $FIELD${Fname} ${Lname}}, ${JobTitle}.";
// Data={"PersTitle":"Mr.","Fname":"Marshall","Lname":"Henley","JobTitle":"Programmer"};
MergeText=Marshall {Henley {is {the }{best }}{man}{at }my wedding."
// Defaults
OpenDelimiter=ifnull(OpenDelimiter,"{");
CloseDelimiter=ifnull(CloseDelimiter,"}");
FunctionCharacter=ifnull(FunctionCharacter,"$");
fd=FunctionCharacter;                               // just keeping things short in code

//
// Variables
ResultsMap=Map();									// where we keep the current variable contexts of all merge info. We "push" and "pop" onto the stack with .add() and .remove(CurrentDepth=ResultsMap.size()-1)
LastDelimWasOpen=true;								// We track whether a block delimiter find follows an open or closed delimiter with this
SequentialIndex=0;									// width index - starts with 0 for first sequential block, and increases with each successive block
EmbeddedIndex=0;									// depth index - starts with 0 for first level containing embedded blocks, and increases with each successive block
Output = "";                                        // string for results
Cursor=0;                                           // where a cursor for current location within processing of MergeText
IsArgument=false;                                   // boolean indicating the current pass already has a stack element associated with an argument to be processed
Index=List();										// ResultsMap index is actually a list
BlockType="";										// String value containing the current block type prior to evaluation and replacement with results text. Because
													//	the text inputs and evaluation reside in the evaluation of MergeText until replacing, this allows us to not worry
													//	about keyword conflicts. We are never checking the value of an unprocessed ResultsMap entry for anything other than
													//	BlockType until it is completely replaced.
//
// START LOOPING TO FIND FIELDS AND PROCESS
Index.add(0);
ResultsMap.put(Index);								// treat the entire string as a block, with an implied block start and end character
counter = leftpad("1",(MergeText.Len()/4).toLong()).replaceAll(" ","1,").toList();           // the lame Deluge way of creating a counted loop => a list of serialized characters, i starts a 0
for each index i in counter {
	// search for either block{} delimiter
	SequentialIndex=0;			// default each pass
	BlockType="BLOCK"			// default each pass
	OpenDelimiterLocation=MergeText.mid(Cursor).find(OpenDelimiter);
	ClosedDelimiterLocation=MergeText.mid(Cursor).find(CloseDelimiter);
	if(OpenDelimiterLocation<0 && ClosedDelimiterLocation<0) {			// we're done -> no delimiters found, treat like a closed delimiter was found
		if(Cursor<MergeText.len()) {
			Output=Output+MergeText.mid(Cursor);						// tack on what's left
		}
		break;
	}
	else if(OpenDelimiterLocation>=0) {									// Open Delimiter found
		if(LastDelimWasOpen) {

			If(Cursor<OpenDelimiterLocation) {							// there is some preceding text - treat as a sequential block starting at 0
				Index.add(SequentialIndex);								// SequentialIndex always defaults to 0
				ResultsMap.put(Index,MergeText.mid(cursor,OpenDelimiterLocation));
				SequentialIndex=1;
			}
			Index.add(SequentialIndex);
			ResultsMap.put(Index,BlockType);
		}
		else {
			SequentialIndex=Index.get(Index.size()-1)+1;				// Instead of Increment Function (because Deluge would convert have to text and back)
			Index.remove(Index.size()-1);
			Index.add(SequentialIndex);
			If(Cursor<OpenDelimiterLocation) {							// there is some preceding text - treat as a sequential block starting from SequentialIndex
				Index.add(SequentialIndex);
				ResultsMap.put(Index,MergeText.mid(cursor,OpenDelimiterLocation));
				SequentialIndex=SequentialIndex+1;
			}
			Index.add(SequentialIndex);									// add block entry into ResultsMap
			ResultsMap.put(Index,BlockType);

		}
		LastDelimWasOpen=true;
		Cursor=OpenDelimiterLocation+1;
	}
	else if(ClosedDelimiterLocation>=0) {								// Close delimiter found
		if(LastDelimWasOpen) {											// process what is in ResultsMap at Index.get(Index.size()-1)
			BlockType=ResultsMap.get(Index);
			if(BlockType)="BLOCK") {
				ResultsMap.get(Index)=MergeText.mid(Cursor,ClosedDelimiterLocation);
			}
		}
		else {															// process what is in Index.get( Index.size()-1 - (Index.get(Index.size()-1) ), the previous dimension
			BlockType=ResultsMap.get(Index.get(Index.size()-1-Index.get(Index.size()-1)));

		}
 		LastDelimWasOpen=false;
	}
}
// END LOOP
//
// return function value
if(!isnull(e)) {
	return e;
}
else {
	return Output;
}
}
