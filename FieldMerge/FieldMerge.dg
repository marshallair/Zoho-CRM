string standalone.FieldMerge(String MergeText,String Data,String OpenDelimiter,String CloseDelimiter,String FunctionCharacter)
{
// USAGE:
//	standalone.FieldMerge(MergeText,Data,null,null,null)
//	standalone.FieldMerge(MergeText,Data,OpenDelimiter,CloseDelimiter,FunctionCharacter)
//  NOTE: MergeText requires double escapes (\\) for delimiters (e.g. \\{ ) and function character (e.g \\$) if trying to use as literal
// 		characters, AND if Zoho has turned on \n for your instance of CRM. Not needed if you haven't requested \n to be turned on.
//		The reason for this is that Deluge with escaped strings turned on only recognizes \\, \t, \n, \", and \'//
//  NOTE: Deluge maps with an a list used as key value(s) apparently use an internal pointer or something. We have to "clone" the list to use it using duplicate().
// 		Otherwise, it changes the map variable when we change the value of CurrentIndex! Also, without using toList() with this function, occasionally the new index
// 		elements are converted to strings (another bug), such as ["0","1"] instead of [0,1], for example. Therefore, we always use listvar.duplicate(0).toList() 
// 		when assigning a list to a map key...
// TEST:
//	MergeText="My name is {${PersTitle} $FIELD${Fname} ${Lname}}, ${JobTitle}.";
//	Data={"PersTitle":"Mr.","Fname":"Marshall","Lname":"Henley","JobTitle":"Programmer"};
// 	MergeText = "Marshall {Henley {is the best man }}at my wedding.";
//  MergeText = "Marsh\\}all {Henley {is {the }}{b{e}{s}{t} }\\$}{man\\{ }at my {wedding}.";
//	MergeText = "Marshall Henley {is the }{best}";
//
// ERROR HANDLING:
if(MergeText="")
{
	return "MergeText is empty.";
}
// DEFAULTS:
if(OpenDelimiter == "")
{
	OpenDelimiter = "{";
}
if(CloseDelimiter == "")
{
	CloseDelimiter = "}";
}
if(FunctionCharacter == "")
{
	FunctionCharacter = "$";
}
//
// Variables (int BlockProcess defined later)
MergeText = OpenDelimiter + MergeText + CloseDelimiter;
ResultsMap = Map();
LastDelimiterWasOpen = true;
TextCursor = 0;
CurrentIndex = List();
IsArgument = false;
End = MergeText.len() - 1;
ResultText = "";
// these are used for readability, below
NewEblock = 1;
NewSblock = 2;
EndSblock = 3;
EndEblock = 4;
//
// FUNCTION
// Loop to find blocks (lame way of do/while loops in Deluge - must break to exit)
counter = leftpad("1",MergeText.Len().toLong()).replaceAll(" ","1,").toList();
for each index i in counter
{
	// Use replaceall on string Temp to ignore escaped delimiters and do location tracking for delimiters on Temp
	Temp = MergeText.mid(TextCursor).replaceAll('\' + OpenDelimiter,"__",true).replaceAll('\' + CloseDelimiter,"__",true);
	OpenDelimiterLocation = Temp.find(OpenDelimiter);
	ClosedDelimiterLocation = Temp.find(CloseDelimiter);
	//
	// Process which delimiter was found first and therefore which block type based on last delimiter found
	if(OpenDelimiterLocation < 0 && ClosedDelimiterLocation < 0)
	{
		// THIS SHOULD NEVER HAPPEN DUE TO MergeText=OpenDelimiter+MergeText+CloseDelimiter above
		break;
	}
	else if(OpenDelimiterLocation < 0)
	{
		// only closed delimiter found
		BlockProcess = if(LastDelimiterWasOpen,3,4);
	}
	else if(ClosedDelimiterLocation < 0)
	{
		// only open delimiter found
		BlockProcess = if(LastDelimiterWasOpen,1,2);
	}
	else
	{
		// both delimiters found
		BlockProcess = if(OpenDelimiterLocation < ClosedDelimiterLocation && LastDelimiterWasOpen,1,if(OpenDelimiterLocation < ClosedDelimiterLocation && !LastDelimiterWasOpen,2,if(OpenDelimiterLocation > ClosedDelimiterLocation && LastDelimiterWasOpen,3,if(OpenDelimiterLocation > ClosedDelimiterLocation && !LastDelimiterWasOpen,4,null))));
	}
	//
	if(BlockProcess == NewEblock)
	{
		// Add a new Embedded level to index
		CurrentIndex.add(0);
		//
		// Add preprocess key-value pairs to map
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// NEED SOME WAY TO REESTABLISH THE NEW CUrrentIndex after the following
		ResultsMap.putAll(standalone.PreprocessBlock(MergeText.mid(cursor,OpenDelimiterLocation+1), CurrentIndex, OpenDelimiter, CloseDelimiter, FunctionCharacter).toMap());
		//
		// update processing vars
		TextCursor = TextCursor + OpenDelimiterLocation + 1;
		LastDelimiterWasOpen = true;
	}
	else if(BlockProcess == NewSblock)
	{
		if(OpenDelimiterLocation > 0)
		{
			// there is some preceding text - treat as a completed Sblock preceding current Sblock
			CurrentIndex = standalone.IncrementSequentialIndex(CurrentIndex).toList(",");
			ResultsMap.put(CurrentIndex.duplicate(0).toList(),MergeText.mid(TextCursor,OpenDelimiterLocation + TextCursor));
		}
		TextCursor = TextCursor + OpenDelimiterLocation + 1;
		CurrentIndex = standalone.IncrementSequentialIndex(CurrentIndex).toList(",");
		// Add preprocess key-value pairs to map
		ResultsMap.putAll(standalone.PreprocessBlock(MergeText,CurrentIndex,TextCursor-1,OpenDelimiter,CloseDelimiter,FunctionCharacter).toMap());
		LastDelimiterWasOpen = true;
	}
	else if(BlockProcess == EndSblock)
	{
		ResultsMap.putAll(standalone.PostprocessBlock(ResultsMap,CurrentIndex).toMap());
		TextCursor = TextCursor + ClosedDelimiterLocation + 1;
		LastDelimiterWasOpen = false;
	}
	else if(BlockProcess == EndEblock)
	{
		// Complete Embedded blocks - process what is in CurrentIndex.get( CurrentIndex.size()-1 - (CurrentIndex.get(CurrentIndex.size()-1) ), the previous dimension
		if(ClosedDelimiterLocation > 0)
		{
			// there is some ending text - treat as a completed Sblock preceding current Sblock
			CurrentIndex = standalone.IncrementSequentialIndex(CurrentIndex).toList();
			ResultsMap.put(CurrentIndex.duplicate(0).toList(),MergeText.mid(TextCursor,ClosedDelimiterLocation + TextCursor));
		}
		ParentBlockKey = standalone.ParentBlockKey(ResultsMap).toList(",");
		BlockType = standalone.ParentBlockValue(ResultsMap);
		Indices = standalone.ParentSubIndices(ResultsMap).toList("|");
		if(BlockType = "BLOCK")
		{
			ResultsMap.put(ParentBlockKey.duplicate().toList(),"");
			// iterate through concatenation of each sub block
			for each  x in Indices
			{
				ResultsMap.put(ParentBlockKey.toList(),ResultsMap.get(ParentBlockKey.toList()) + ResultsMap.get(x.toList()));
				ResultsMap.remove(x.toList());
			}
			// Reset CurrentIndex to "last item" which is now the parent
			CurrentIndex = ParentBlockKey;
		}
		TextCursor = TextCursor + ClosedDelimiterLocation + 1;
		LastDelimiterWasOpen = false;
	}
	if(TextCursor > End)
	{
		// we're done
		break;
	}
}
ResultText = ResultsMap.get("[0]".toList());
if(ResultText == "BLOCK")
{
	ResultText = "{ERROR:\"001 MISMATCHED BRACKETS\"}";
}
return standalone.EscapeCharacters(ResultText,OpenDelimiter + CloseDelimiter + FunctionCharacter);
}