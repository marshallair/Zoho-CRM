string standalone.FieldMerge(String MergeText,String Data,String OpenDelimiter,String CloseDelimiter,String FunctionCharacter)
{
// USAGE:
//	standalone.FieldMerge(MergeText,Data,null,null,null)
//	standalone.FieldMerge(MergeText,Data,OpenDelimiter,CloseDelimiter,FunctionCharacter)
//  NOTE: MergeText requires double escapes (\\) for delimiters (e.g. \\{ ) and function character (e.g \\$) if trying to use as literal
// 		characters, AND if Zoho has turned on \n for your instance of CRM. Not needed if you haven't requested \n to be turned on.
//		The reason for this is that Deluge with escaped strings turned on only recognizes \\, \t, \n, \", and \'//
//  NOTE: Deluge maps with an a list used as key value(s) apparently use an internal pointer or something. We have to "clone" the list to use it using duplicate().
// 		Otherwise, it changes the map variable when we change the value of CurrentIndex! Also, without using toList() with this function, occasionally the new index
// 		elements are converted to strings (another bug), such as ["0","1"] instead of [0,1], for example. Therefore, we always use listvar.duplicate(0).toList() 
// 		when assigning a list to a map key...
// TEST:
//	MergeText="My name is {${PersTitle} $FIELD${Fname} ${Lname}}, ${JobTitle}.";
//	Data={"PersTitle":"Mr.","Fname":"Marshall","Lname":"Henley","JobTitle":"Programmer"};
// 	MergeText = "Marshall {Henley {is the best man }}at my wedding.";
//  MergeText = "Marsh\\}all {Henley {is {the }}{b{e}{s}{t} }\\$}{man\\{ }at my {wedding}.";
//	MergeText = "Marshall Henley {is the }{best}";
//
// TRIVIAL CASE:
if(MergeText=="")
{
	return "";
}
// DEFAULTS:
if(OpenDelimiter == "")
{
	OpenDelimiter = "{";
}
if(CloseDelimiter == "")
{
	CloseDelimiter = "}";
}
if(FunctionCharacter == "")
{
	FunctionCharacter = "$";
}
//
// VARIABLES
MergeText = OpenDelimiter + MergeText + CloseDelimiter;
LastDelimiterWasOpen = true;
//
// ResultsMap structure used for most function interfaces
ResultsMap = Map();
ResultsMap.put("txt",MergeText); 				// doesn't change, string
ResultsMap.put("data",Data);					// All the data
ResultsMap.put("od",OpenDelimiter); 			// doesn't change, single character
ResultsMap.put("cd",CloseDelimiter); 			// doesn't change, single character
ResultsMap.put("fc",FunctionCharacter); 		// doesn't change, single character
ResultsMap.put("end",MergeText.len() - 1); 		// End position, doesn't change, integer
// these change on each parse cycle below:
ResultsMap.put("o_loc",-1); 					// OpenDelimiterLocation integer
ResultsMap.put("c_loc",-1); 					// ClosedDelimiterLocation integer
ResultsMap.put("curs",0) 						// TextCursor integer
ResultsMap.put("chunk","");						// CurrentChunk string
ResultsMap.put("bp",0);							// BlockProcess integer
ResultsMap.put("ind",null);						// CurrentIndex

//
// FUNCTION
// Loop to find and parse blocks (lame way of do/while loops in Deluge - break; to exit)
counter = leftpad("1",MergeText.Len().toLong()).replaceAll(" ","1,").toList();   // more than we need, never less
for each index i in counter
{
	// Use replaceall on string Temp to ignore escaped delimiters and do location tracking for delimiters on Temp
	Temp = MergeText.mid(TextCursor).replaceAll('\' + OpenDelimiter,"__",true).replaceAll('\' + CloseDelimiter,"__",true);
	OpenDelimiterLocation = Temp.find(OpenDelimiter);
	ClosedDelimiterLocation = Temp.find(CloseDelimiter);
	ResultsMap.put("o_loc",OpenDelimiterLocation);
	ResultsMap.put("c_loc",ClosedDelimiterLocation);

	//
	// Process which delimiter was found first and therefore which block type based on last delimiter found
	if(OpenDelimiterLocation < 0 && ClosedDelimiterLocation < 0)
	{
		// THIS SHOULD NEVER HAPPEN DUE TO MergeText=OpenDelimiter+MergeText+CloseDelimiter above
		return "Error: OpenDelimiter and ClosedDelimiter were not found. Consult your developer.";
	}
	else if(OpenDelimiterLocation < 0)
	{
		// only closed delimiter found
		BlockProcess = if(LastDelimiterWasOpen,3,4);
	}
	else if(ClosedDelimiterLocation < 0)
	{
		// only open delimiter found
		BlockProcess = if(LastDelimiterWasOpen,1,2);
	}
	else
	{
		// both delimiters found
		BlockProcess = if(OpenDelimiterLocation < ClosedDelimiterLocation && LastDelimiterWasOpen,1,if(OpenDelimiterLocation < ClosedDelimiterLocation && !LastDelimiterWasOpen,2,if(OpenDelimiterLocation > ClosedDelimiterLocation && LastDelimiterWasOpen,3,if(OpenDelimiterLocation > ClosedDelimiterLocation && !LastDelimiterWasOpen,4,null))));
	}
	LastDelimiterWasOpen=(BlockProcess<3);
	ResultsMap.put("bp",BlockProcess)
	ResultsMap=standalone.PreprocessBlock(ResultsMap).toMap();
	if(TextCursor > End)
	{
		// we're done
		break;
	}
}

return standalone.EscapeCharacters(ResultsMap.get("[0]".toList()),OpenDelimiter + CloseDelimiter + FunctionCharacter);
}