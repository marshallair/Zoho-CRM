string standalone.PreprocessBlock(string MergeText,int BlockDelimiterLocation, string strIndex, String OpenDelimiter,String CloseDelimiter,String FunctionCharacter)
{
// USAGE:
//  standalone.PreprocessBlock(Text,Index)
//
// NOTES:
//  Processes Text starting from position 0 as the next block. Returns a map string that needs added to ResultsMap, with a block type always starting first, then preload blocks, such as:
//  {"blocktype":"IF_RESULT","preload_blocks":{[0,1,3,0]:"IF_COND",[0,1,3,1],[0,1,3,2]:"IF_TRUE",[0,1,3,3]:"IF_FALSE"}}
//  Care needs taken to add the blocktype block and the preload blocks to ResultsMap immediately after calling this function.
//
// TEST:
 MergeText="$F${id,ID: {$},missing}";
 Cursor=3;
 Index=[0,0,1];
//
// FUNCTION:
m=map();
if(trim(MergeText)="")
{
    return null;
}
else
{
    //  Variables, defaults
    Index=strIndex.toList();
    BlockType="BLOCK";
    if(OpenDelimiter=="")
    {
        OpenDelimiter="{";
    }
    if(CloseDelimiter=="")
    {
        CloseDelimiter="}";
    }
    if(FunctionCharacter=="")
    {
        FunctionCharacter="$";
    }
    //
    // Every function and operator is evaluated here. To add new operators or functions, add them here, and then call their function
    if(upper(MergeText.mid(BlockDelimiterLocation - 1, BlockDelimiterLocation)) == FunctionCharacter
        ||standalone.IsBlockThisFunction("F",MergeText,BlockDelimiterLocation,FunctionCharacter))
    {
        // Field (F) function
//         m.putAll(standalone.fmfunc_FIELD(Index).toMap());
    }
    else if(standalone.IsBlockThisFunction("IF",MergeText,BlockDelimiterLocation,FunctionCharacter))
    {
        // IF function
//         m.putAll(standalone.fmfunc_IF(Index).toMap());
    }
}
return m;
}